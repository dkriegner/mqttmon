#!/usr/bin/env python3

# This file is part of mqttmon.
#
# mqttmon is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2015 Dominik Kriegner <dominik.kriegner@gmail.com>

import argparse
import collections
import configparser
import copy
import curses
import curses.panel
import itertools
import time
import sys

import paho.mqtt.client as paho


class TopicList(dict):
    """
    class extending a Python dictionary to hold the information about different
    topics so far received from the broker. For every topic a asociated
    MessageList is created.
    """
    def addTopic(self, topicName):
        """
        add new Topic to the TopicList

        Parameter
        ---------
         topicName: name of the topic to be added to the list
        """
        super().__setitem__(topicName, MessageList(topicName))

    def addMessage(self, msg):
        """
        add new Message to a certain topic. The topic is found from the
        msg.topic property.

        Parameter
        ---------
         msg:   Message object to be added to the list of messages
        """
        topic = msg.topic
        # add Topic to TopicList
        if topic not in super().keys():
            self.addTopic(topic)
        super().__getitem__(topic).append(msg)


class MessageList(collections.deque):
    """
    List of messages. This uses collections.deque
    and provides textlines to display the message on the screen.
    """

    def __init__(self, name, maxlen=1024):
        """
        initialize the message list

        Parameter
        ---------
         name:  name of the Messagelist
        """
        self.name = name
        self.lines = collections.deque(maxlen=maxlen*2)
        super().__init__(maxlen=maxlen)

    def append(self, msg):
        """
        append a msg to the list.

        Parameter
        ---------
         msg:   Message object to be added to the list
        """
        self.lines += msg.listLines()
        super().append(msg)


class Message(object):
    """
    Message object holding all the information about a message. In addition to
    the message itself this are the topic under which the message was received
    and a timestamp (when the message was received)

    Methods are provided to help to show the message on the screen.
    """
    _timefmt = "%H:%M:%S"

    def __init__(self, msg, topic):
        """
        initialize the Message by setting its content and topic.

        Parameter
        ---------
         msg:   Message content
         topic: topic of the message
        """
        self.timestamp = time.time()
        self.timestr = time.strftime(self._timefmt,
                                     time.localtime(self.timestamp))
        self.topic = topic
        self.message = msg

    def listLines(self):
        """
        method to return a list of lines describing the message.

        Every entry in the returned list includes a tuple of (intentation,
        linetext, curses_attribute) which can be used to display the message on
        the screen
        """
        ret = [(0, self.topic, curses.A_BOLD), ]
        try:
            for line in self.message.decode('utf-8').splitlines():
                ret.append((1, line, curses.A_NORMAL))
        except UnicodeDecodeError:
            ret.append((1, 'msg not decodable to UTF-8', curses.A_UNDERLINE))
        return ret


class Communicator(object):
    """
    class to handle the communication with the MQTT Broker
    """
    def __init__(self, address, port, user=None, passwd=None, userdata=None):
        """
        initialization of the connection to the MQTT Broker

        Parameter
        ---------
         address:   address of the broker
         port:      TCP port used by the Broker
         user:      username used for the authentication (optional)
         passwd:    password used for the authentication (optional)
         userdata:  data object forwarded to all the callbacks
        """
        self.client = paho.Client('mqttstatus')
        if user:
            self.client.username_pw_set(user, password=passwd)
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.user_data_set(userdata)
        self.client.connect(address, port, 60)

    def on_connect(self, client, userdata, flags, rc):
        """
        callback upon successfull connection to the broker

        Parameter
        ---------
         client:    the client instance for this callback
         userdata:  the private user data as set by the initialization
         flags:     response flags sent by the broker
         rc:        the connection result
        """
        if 'StatusWindow' in userdata:
            cursesTUI.setStatusMessage(userdata['StatusWindow'],
                                       'Connected with result code '+str(rc))

    def subscribe(self, *args):
        """
        method to subscribe to certain topics of the broker

        Parameter
        ---------
         *args: topics to subscribe to. If none are given a subscription to '#'
                is performed.
        """
        if len(args) == 0:
            self.client.subscribe("#")
        else:
            for t in args:
                self.client.subscribe(t)

    def on_message(self, client, userdata, msg):
        """
        callback upon arrival of a message from the broker.
        The new message is added to the corresponding MessageLists in the
        userdata.

        Parameter
        ---------
         client:    the client instance for this callback
         userdata:  the private user data as set by the initialization.
         msg:       an instance of MQTTMessage. This is a class with members
                    topic, payload, qos, retain.
        """
        # add message to the corresponding message list
        m = Message(msg.payload, msg.topic)
        userdata['TopicList'].addMessage(m)
        userdata['TimeList'].append(m)
        # increase message counter
        userdata['nmsg'] += 1
        # show Message on screen
        if 'StatusWindow' in userdata:
            cursesTUI.setStatusMessage(
                userdata['StatusWindow'],
                'nmsg: {:4d};'.format(userdata['nmsg']), start=1, end=12)
            cursesTUI.setStatusMessage(
                userdata['StatusWindow'],
                'New msg in {topic} at {time}'.format(topic=m.topic,
                                                      time=m.timestr))


class cursesTUI(object):
    """
    The main class of mqttmon. Handles the TUI setup using curses and the
    initialization of the broker connection. After initialization a loop is
    started which handles the user input and update of the display.
    """
    statwidth = 2  # height of the status window area (minimum 2)
    scroll = 0  # integer constant to save the scroll offset

    def __init__(self, stdscr, args):
        """
        initialization of the windows and setting up of the communication

        Parameter
        ---------
         stdscr:    standard screen as supplied by curses.wrapper. used as main
                    window.
        """
        self.ispaused = False  # update mode paused flag
        self.updateMode = 'inplace'  # can be 'continuous'/'inplace'
        self.lines = []

        self.mainWindow = stdscr
        self.initMain()
        self.topicList = TopicList()
        self.timeList = MessageList('TimeList')
        self.userdict = {'TopicList': self.topicList,
                         'TimeList': self.timeList,
                         'MainWindow': self.mainWindow,
                         'MessageWindow': self.msgWindow,
                         'StatusWindow': self.statusWindow,
                         'nmsg': 0}

        # start communication
        self.com = Communicator(args.brokeraddr, args.port, args.username,
                                args.passwd, self.userdict)
        self.com.subscribe(*args.topic)
        self.mainLoop(args.timeout)

    def initMain(self):
        """
        initialize main curses windows.
        """
        self.width_y, self.width_x = self.mainWindow.getmaxyx()

        # message window
        self.msgWindow = curses.newwin(self.width_y - self.statwidth,
                                       self.width_x)
        self.clearMsgWindow()
        wy, wx = self.msgWindow.getmaxyx()
        self.textheight = wy - 2
        self.contentwidth = wx - 2

        # status window
        self.statusWindow = curses.newwin(self.statwidth, self.width_x,
                                          self.width_y - self.statwidth, 0)
        self.redrawStatus()

    def clearMsgWindow(self, title='Messages'):
        """
        clears the message window and redraws its border.
        """
        self.msgWindow.erase()
        self.msgWindow.border(0, 0, 0, 0)
        self.msgWindow.addstr(0, 2, ' {} '.format(title))
        self.msgWindow.move(1, 1)

    def redrawStatus(self):
        """
        redraws the status window keyboard shortcuts
        """
        h, w = self.statusWindow.getmaxyx()
        if w < 58:
            raise Exception("Window is too narrow, needs at least 58 width!")
        self.statusWindow.addstr(1, 1, 'q - Quit;')
        self.statusWindow.addstr(1, 11, 'updates: ')
        if self.updateMode == 'continuous':
            self.statusWindow.addstr(1, 20, 'i-inplace')
            self.statusWindow.addstr(1, 30, 'c-continuous', curses.A_BOLD)
            self.statusWindow.addstr(1, 42, ';')
        else:
            self.statusWindow.addstr(1, 20, 'i-inplace', curses.A_BOLD)
            self.statusWindow.addstr(1, 30, 'c-continuous;')
        if self.ispaused:
            self.statusWindow.addstr(1, 44, 'p - (un)pause', curses.A_BOLD)
        else:
            self.statusWindow.addstr(1, 44, 'p - (un)pause')

    def resize(self):
        """
        function to handle a resizing of the terminal window
        """
        old_width_y, old_width_x = (self.width_y, self.width_x)
        self.width_y, self.width_x = self.mainWindow.getmaxyx()
        self.msgWindow.resize(self.width_y - self.statwidth, self.width_x)
        self.resizeMsgWindow(old_width_y, old_width_x)
        self.statusWindow.resize(self.statwidth, self.width_x)
        self.statusWindow.mvwin(self.width_y - self.statwidth, 0)
        self.update()

    def resizeMsgWindow(self, old_width_y, old_width_x):
        """
        function handling a resizing of the message window. this avoids a full
        redraw of the Message list and adds/removes only the necesarry content

        Parameter
        ---------
         old_width_y, old_width_x: previous size of the main window
        """
        old_textheight, old_contentwidth = (self.textheight, self.contentwidth)
        wy, wx = self.msgWindow.getmaxyx()
        self.textheight = wy - 2
        self.contentwidth = wx - 2
        # vertical change
        step = 1 if (self.width_y - old_width_y) > 0 else -1
        for cl in range(old_width_y+step, self.width_y+step, step):
            if cl > old_width_y:
                self.msgWindow.move(old_textheight+1, 1)
                self.msgWindow.insertln()
            elif self.textheight > len(self.lines):
                self.msgWindow.move(self.textheight+1, 1)
                self.msgWindow.deleteln()
            else:
                self.msgWindow.move(1, 1)
                self.msgWindow.deleteln()
        # horizontal change
        step = 1 if (self.width_x - old_width_x) > 0 else -1
        for cc in range(old_width_x+step, self.width_x+step, step):
            if cc > old_width_x:
                for py in range(1, 1+self.textheight):
                    self.msgWindow.insch(py, old_contentwidth+1, ' ')
            else:
                for py in range(1, 1+self.textheight):
                    self.msgWindow.delch(py, self.contentwidth+1)
        # fix border
        self.msgWindow.border(0, 0, 0, 0)

    def mainLoop(self, timeout):
        """
        main loop of the program. checks for new messages or keyboard input
        and updates the display. For the input checking a timeout (ms) is
        used.
        """
        self.msgWindow.timeout(timeout)
        while True:
            # call the communication loop of the MQTT client
            try:
                self.com.client.loop(timeout=timeout/1000/10)
            except UnicodeDecodeError:
                self.setStatusMessage(self.statusWindow,
                                      'UnicodeDecodeError in MQTT client')
            # check key-events
            c = self.msgWindow.getch()
            if c == ord('q'):
                sys.exit()
            elif c == ord('c'):
                self.scroll = 0
                self.clearMsgWindow()
                self.updateMode = 'continuous'
            elif c == ord('i'):
                self.scroll = 0
                self.clearMsgWindow()
                self.updateMode = 'inplace'
            elif c == ord('p'):
                self.ispaused = not self.ispaused
            elif c in (curses.KEY_UP, 65):
                self.scroll += 1
            elif c in (curses.KEY_DOWN, 66) and self.scroll > 0:
                self.scroll -= 1
            elif c == curses.KEY_RESIZE:
                self.resize()
            self.updateMsgList()
            self.redrawStatus()
            self.update()

    def updateMsgList(self):
        """
        the message list will be updated depending on the current update mode
        """
        self.msgWindow.move(1, 1)
        window = self.msgWindow
        if not self.ispaused:
            if self.updateMode == 'inplace':
                self.lines = []
                for k in sorted(self.topicList):
                    self.lines += self.topicList[k][-1].listLines()
            elif self.updateMode == 'continuous':
                self.lines = copy.copy(self.timeList.lines)
        if len(self.lines) < self.textheight:
            self.scroll = 0
        if self.scroll > abs(len(self.lines) - self.textheight):
            self.scroll = len(self.lines) - self.textheight
        lstart = -min(self.textheight, len(self.lines)) - self.scroll
        scrollinfo = ' {}-{}/{} '.format(
            len(self.lines) + lstart,
            len(self.lines) + lstart + min(len(self.lines), self.textheight),
            len(self.lines))
        self.msgWindow.addstr(self.textheight+1,
                              self.contentwidth - len(scrollinfo),
                              scrollinfo)
        self.msgWindow.move(1, 1)
        lcnt = 0
        lstart = lstart if lstart > 0 else len(self.lines)+lstart
        shownlines = itertools.islice(self.lines, lstart, None)
        for c, (i, l, a) in enumerate(shownlines):
            if c >= self.textheight:
                break
            self.addLineStr(window, l, self.contentwidth-i, 1+i, attr=a)

    def update(self):
        """
        redraws the screen content after a string change
        """
        self.msgWindow.refresh()
        self.statusWindow.refresh()

    @staticmethod
    def setStatusMessage(window, string, start=14, end=-1,
                         attr=curses.A_NORMAL):
        """
        Method setting the status message in the status bar. Here the arrival
        of a new message/connection to the broker/subscription to a new
        topic... should be shown.

        Parameter
        ---------
         window:    curses window where the string should be shown
         string:    message to be shown
         start:     intentation of the beginning of the message
         end:       end position of the message (-1 = line end)
         attr:      curses attribute for the text
        """
        wy, wx = window.getmaxyx()
        window.move(0, start)
        if end == -1:
            end = wx - 2
            window.clrtoeol()
        for line in string.splitlines():
            window.addnstr(line, end-start, attr)

    @staticmethod
    def addMultiLineStr(window, string, start=1, end=-1, attr=curses.A_NORMAL):
        """
        Method adding a string (possibly containing multiple line breaks) to a
        curses window.

        Parameter
        ---------
         window:    curses window where the string should be shown
         string:    message to be shown
         start:     intentation of the beginning of the message. Every line
                    will be intented by this amount
         end:       end position of the message (-1 = line end)
         attr:      curses attribute for the text
        """
        y, x = window.getyx()
        wy, wx = window.getmaxyx()
        for line in string.splitlines():
            cursesTUI.addLineStr(window, line, wy-start+end, start, attr=attr)

    @staticmethod
    def addLineStr(window, line, nchar, start=1, attr=curses.A_NORMAL):
        """
        Method adding a string (without line breaks) to a curses window.

        Parameter
        ---------
         window:    curses window where the string should be shown
         string:    message to be shown
         start:     intentation of the beginning of the message. Every line
                    will be intented by this amount
         end:       end position of the message (-1 = line end)
         attr:      curses attribute for the text
        """
        y, x = window.getyx()
        window.move(y, 1)
        window.addstr(' '*(start-1), curses.A_NORMAL)
        window.move(y, start)
        window.addnstr(line, nchar, attr)
        # clear the rest of the line without destroying the window border
        y, x = window.getyx()
        # this complicated treatment here is necessary for special character
        # functionality
        window.addstr(' '*(nchar-(x-start)), curses.A_NORMAL)
        y, x = window.getyx()
        window.move(y+1, start)


if __name__ == '__main__':
    conf_parser = argparse.ArgumentParser(add_help=False)
    conf_parser.add_argument('-c', '--config', metavar='conffile', type=str,
                             default='', help='specify config file')
    args, remaining_argv = conf_parser.parse_known_args()
    defaults = {
        'port': 1883,
        'passwd': None,
        'username': None,
        'topic': '#',
        'timeout': 100
        }
    if args.config:
        config = configparser.SafeConfigParser()
        config.read([args.config])
        for item, val in config.items("Defaults"):
            defaults[item] = val

    parser = argparse.ArgumentParser(parents=[conf_parser],
                                     description='curses TUI for MQTT message'
                                     ' monitoring')
    parser.set_defaults(**defaults)
    parser.add_argument('-p', '--port', metavar='port', type=int,
                        help='TCP port for the MQTT broker')
    parser.add_argument('-u', '--user', dest='username', metavar='username',
                        type=str, help='user name for the broker connection'
                        ' (empty if not needed)')
    parser.add_argument('-P', '--pass', metavar='passwd', dest='passwd',
                        type=str, help='password for the broker connection'
                        ' (empty if not needed)')
    parser.add_argument('-t', '--topic', metavar='topic', type=str, nargs='+',
                        help='topics to subscribe')
    parser.add_argument('brokeraddr', metavar='address', type=str,
                        help='Address of the MQTT broker')

    args = parser.parse_args(remaining_argv)

    curses.wrapper(cursesTUI, args)
