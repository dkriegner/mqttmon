#!/usr/bin/env python3

# This file is part of mqttmon.
#
# mqttmon is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2015 Dominik Kriegner <dominik.kriegner@gmail.com>

import curses
import curses.panel
import time
import sys
import paho.mqtt.client as paho

#########################################################
# Global variables
BROKERADDR = 'test.mosquitto.org' # hostname or IP-address of the broker
PORT = 1883 # port number of the broker
USER = None # user name used for the connection
PASSWD = None # password used for the connection
TOPIC = '#' # topic to which the monitor should connect to
##########################################################
# NO CHANGES NEEDED BELOW FOR THE BASIC USE OF THIS SCRIPT

class TopicList(dict):
    """
    class extending a Python dictionary to hold  the information about
    different topics so far received from the broker for every topic a
    asociated message list is created
    """
    def addTopic(self, topicName):
        """
        add new Topic to the TopicList
        """
        super().__setitem__(topicName, MessageList(topicName))

    def addMessage(self, msg):
        """
        add new Message to a certain topic
        """
        topic = msg.topic
        # add Topic to TopicList
        if topic not in super().keys():
            self.addTopic(topic)
        super().__getitem__(topic).append(msg)


class MessageList(list):
    """
    List of messages. This extends the builtin type list
    by routines to display the messaged on the screen.
    """
    def __init__(self, name):
        self.name = name
        self.lines = []
        super().__init__()

    def append(self, msg):
        self.lines += msg.listLines()
        super().append(msg)


class Message(object):
    """
    Message object holding all the information about a message. In addition to
    the message itself this are the topic under which the message was received
    a timestamp (when the message was received)

    Methods are provided to show the message on the screen.
    """
    def __init__(self, msg, topic):
        self.timestamp = time.time()
        self.timestr = time.strftime("%H:%M:%S", time.localtime(self.timestamp))
        self.topic = topic
        self.message = msg
 
    def listLines(self):
        ret = [(0, self.topic, curses.A_BOLD),]
        try:
            for line in self.message.decode('utf-8').splitlines():
                ret.append((1, line, curses.A_NORMAL))
        except UnicodeDecodeError:
            ret.append((1, 'msg not decodable to UTF-8', curses.A_UNDERLINE))
        return ret


class Communicator(object):
    """
    class to handle the communication with the MQTT Broker
    """
    def __init__(self, address, port, user=None, passwd=None, userdata=None):
        self.client = paho.Client('mqttstatus')
        if user:
            self.client.username_pw_set(user, password=passwd)
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.user_data_set(userdata)
        self.client.connect(address, port, 60)

    def on_connect(self, client, userdata, flags, rc):
        if 'StatusWindow' in userdata:
            cursesGUI.setStatusMessage(userdata['StatusWindow'], 
                                       'Connected with result code '+str(rc))
        
    def subscribe(self, *args):
        if len(args) == 0:
            self.client.subscribe("#")
        else:
            for t in args:
                self.client.subscribe(t)

    def on_message(self, client, userdata, msg):
        # add message to the corresponding message list
        m = Message(msg.payload, msg.topic)
        userdata['TopicList'].addMessage(m)
        userdata['TimeList'].append(m)
        # increase message counter
        userdata['nmsg'] += 1
        # show Message on screen
        if 'StatusWindow' in userdata:
            cursesGUI.setStatusMessage(userdata['StatusWindow'], 
            'nmsg: {:4d};'.format(userdata['nmsg']), start=1, end=12)
            cursesGUI.setStatusMessage(userdata['StatusWindow'], 
                'New msg in {topic} at {time}'.format(topic=m.topic,
                                                      time=m.timestr))


class cursesGUI(object):
    statwidth = 2 # height of the status window area (minimum 2)
    scroll = 0 # integer constant to save the scroll offset

    def __init__(self, stdscr):
        self.mainWindow = stdscr
        self.initMain()
        self.topicList = TopicList()
        self.timeList = MessageList('TimeList')
        self.userdict = {'TopicList': self.topicList,
                         'TimeList': self.timeList,
                         'MainWindow': self.mainWindow,
                         'MessageWindow': self.msgWindow,
                         'StatusWindow': self.statusWindow,
                         'nmsg': 0}
        self.updateMode = 'inplace' # can be 'continuous'/'topic'
        self.lines = []

        # start communication
        self.com = Communicator(BROKERADDR, PORT, USER, PASSWD, self.userdict)
        self.com.subscribe(TOPIC)
        self.mainLoop()
    
    def initMain(self):
        """
        initialize curses windows
        """
        self.width_y, self.width_x = self.mainWindow.getmaxyx()

        # message window
        self.msgWindow = curses.newwin(self.width_y - self.statwidth, self.width_x)
        self.clearMsgWindow()
        wy, wx = self.msgWindow.getmaxyx()
        self.textheight = wy - 2
        self.contentwidth = wx - 2

        # status window
        self.statusWindow = curses.newwin(self.statwidth, self.width_x, self.width_y - self.statwidth, 0)
        self.redrawStatus()
   
    def clearMsgWindow(self, title='Messages'):
        self.msgWindow.erase()
        self.msgWindow.border(0, 0, 0, 0)
        self.msgWindow.addstr(0, 2, ' {} '.format(title))
        self.msgWindow.move(1, 1)

    def redrawStatus(self):
        self.statusWindow.addstr(1, 1, 'q - Quit; i/c - inplace/continuous updates; p - (un)pause')

    def resize(self):
        self.old_width_y, self.old_width_x = (self.width_y, self.width_x)
        self.width_y, self.width_x = self.mainWindow.getmaxyx()
        self.msgWindow.resize(self.width_y - self.statwidth, self.width_x)
        self.resizeMsgWindow()
        self.statusWindow.resize(self.statwidth, self.width_x)
        self.statusWindow.mvwin(self.width_y - self.statwidth, 0)
        self.update()

    def resizeMsgWindow(self):
        old_textheight, old_contentwidth = (self.textheight, self.contentwidth)
        wy, wx = self.msgWindow.getmaxyx()
        self.textheight = wy - 2
        self.contentwidth = wx - 2
        #vertical change
        step = 1 if (self.width_y - self.old_width_y) > 0 else -1
        for cl in range(self.old_width_y+step, self.width_y+step, step):
            if cl > self.old_width_y:
                self.msgWindow.move(old_textheight+1, 1)
                self.msgWindow.insertln()
            elif self.textheight>len(self.lines):
                self.msgWindow.move(self.textheight+1, 1)
                self.msgWindow.deleteln()
            else:
                self.msgWindow.move(1, 1)
                self.msgWindow.deleteln()
        # horizontal change
        step = 1 if (self.width_x - self.old_width_x) > 0 else -1
        for cc in range(self.old_width_x+step, self.width_x+step, step):
            if cc > self.old_width_x:
                # if screenlines would be known the suitable character could be inserted here directly!
                for py in range(1,1+self.textheight):
                    self.msgWindow.insch(py, old_contentwidth+1, ' ')
            else:
                for py in range(1,1+self.textheight):
                    self.msgWindow.delch(py, self.contentwidth+1)
        # fix border
        self.msgWindow.border(0, 0, 0, 0)                

    def mainLoop(self):
        """
        main loop of the program
        """
        self.msgWindow.timeout(20)
        updating = True
        while True:
            self.com.client.loop(timeout=0.05)
            # check key-events
            c = self.msgWindow.getch()
            if c == ord('q'):
                sys.exit()
            elif c == ord('c'):
                self.scroll = 0
                self.clearMsgWindow()
                self.updateMode = 'continuous'
            elif c == ord('i'):
                self.scroll = 0
                self.clearMsgWindow()
                self.updateMode = 'inplace'
            elif c == ord('p'):
                updating = not updating
            elif c == curses.KEY_UP:
                self.scroll += 1
            elif c == curses.KEY_DOWN and self.scroll > 0:
                self.scroll -= 1
            elif c == curses.KEY_RESIZE:
                self.resize()
            if updating:
                self.updateMsgList()
            self.update()

    def updateMsgList(self):
        """
        the message list will be updated depending on the current update mode
        """
        self.msgWindow.move(1, 1)
        window = self.msgWindow
        if self.updateMode == 'inplace':
            self.lines = []
            for k in sorted(self.topicList):
                self.lines += self.topicList[k][-1].listLines()
        elif self.updateMode == 'continuous':
            self.lines = self.timeList.lines
        if len(self.lines) < self.textheight:
            self.scroll = 0
        if self.scroll > abs(len(self.lines) - self.textheight):
            self.scroll = len(self.lines) - self.textheight
        lstart = -min(self.textheight, len(self.lines)) - self.scroll
        scrollinfo = ' {}-{}/{} '.format(len(self.lines) + lstart,
                                         len(self.lines) + lstart + min(len(self.lines), self.textheight),
                                         len(self.lines))
        self.msgWindow.addstr(self.textheight+1, self.contentwidth - len(scrollinfo), scrollinfo)
        self.msgWindow.move(1, 1)
        lcnt = 0
        for c, (i, l, a) in enumerate(self.lines[lstart:]):
            if c >= self.textheight: break
            cursesGUI.addLineStr(window, l, self.contentwidth - i, 1 + i, attr=a)

    def update(self):
        self.msgWindow.refresh()
        self.statusWindow.refresh()
    
    @staticmethod
    def setStatusMessage(window, string, start=14, end=-1, attr=curses.A_NORMAL):
        wy, wx = window.getmaxyx()
        window.move(0, start)
        if end == -1: 
            end = wx - 2
            window.clrtoeol()
        for line in string.splitlines():
            window.addnstr(line, end-start, attr)
    
    @staticmethod
    def addMultiLineStr(window, string, start=1, end=-1, attr=curses.A_NORMAL):
        y, x = window.getyx()
        wy, wx = window.getmaxyx()
        for line in string.splitlines():
            cursesGUI.addLineStr(window, line, wy-start+end, start, attr=attr)

    @staticmethod
    def addLineStr(window, line, nchar, start=1, attr=curses.A_NORMAL):
        y, x = window.getyx()
        window.move(y, 1)
        window.addstr(' '*(start-1), curses.A_NORMAL)
        window.move(y, start)
        window.addnstr(line, nchar, attr)
        y, x = window.getyx() # this complicated treatment here is necessary for special char treatment
        window.addstr(' '*(nchar-(x-start)), curses.A_NORMAL)
        y, x = window.getyx()
        window.move(y+1, start)


if __name__ == '__main__':
    curses.wrapper(cursesGUI)
